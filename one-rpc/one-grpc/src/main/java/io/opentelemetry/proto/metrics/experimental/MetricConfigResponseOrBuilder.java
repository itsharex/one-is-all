// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opentelemetry/proto/metrics/experimental/metrics_config_service.proto

package io.opentelemetry.proto.metrics.experimental;

public interface MetricConfigResponseOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.metrics.experimental.MetricConfigResponse)
        com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Optional. The fingerprint associated with this MetricConfigResponse. Each
     * change in configs yields a different fingerprint. The resource SHOULD copy
     * this value to MetricConfigRequest.last_known_fingerprint for the next
     * configuration request. If there are no changes between fingerprint and
     * MetricConfigRequest.last_known_fingerprint, then all other fields besides
     * fingerprint in the response are optional, or the same as the last update if
     * present.
     * The exact mechanics of generating the fingerprint is up to the
     * implementation. However, a fingerprint must be deterministically determined
     * by the configurations -- the same configuration will generate the same
     * fingerprint on any instance of an implementation. Hence using a timestamp is
     * unacceptable, but a deterministic hash is fine.
     * </pre>
     *
     * <code>bytes fingerprint = 1;</code>
     *
     * @return The fingerprint.
     */
    com.google.protobuf.ByteString getFingerprint();

    /**
     * <pre>
     * A single metric may match multiple schedules. In such cases, the schedule
     * that specifies the smallest period is applied.
     * Note, for optimization purposes, it is recommended to use as few schedules
     * as possible to capture all required metric updates. Where you can be
     * conservative, do take full advantage of the inclusion/exclusion patterns to
     * capture as much of your targeted metrics.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.experimental.MetricConfigResponse.Schedule schedules = 2;</code>
     */
    java.util.List<MetricConfigResponse.Schedule>
    getSchedulesList();

    /**
     * <pre>
     * A single metric may match multiple schedules. In such cases, the schedule
     * that specifies the smallest period is applied.
     * Note, for optimization purposes, it is recommended to use as few schedules
     * as possible to capture all required metric updates. Where you can be
     * conservative, do take full advantage of the inclusion/exclusion patterns to
     * capture as much of your targeted metrics.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.experimental.MetricConfigResponse.Schedule schedules = 2;</code>
     */
    MetricConfigResponse.Schedule getSchedules(int index);

    /**
     * <pre>
     * A single metric may match multiple schedules. In such cases, the schedule
     * that specifies the smallest period is applied.
     * Note, for optimization purposes, it is recommended to use as few schedules
     * as possible to capture all required metric updates. Where you can be
     * conservative, do take full advantage of the inclusion/exclusion patterns to
     * capture as much of your targeted metrics.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.experimental.MetricConfigResponse.Schedule schedules = 2;</code>
     */
    int getSchedulesCount();

    /**
     * <pre>
     * A single metric may match multiple schedules. In such cases, the schedule
     * that specifies the smallest period is applied.
     * Note, for optimization purposes, it is recommended to use as few schedules
     * as possible to capture all required metric updates. Where you can be
     * conservative, do take full advantage of the inclusion/exclusion patterns to
     * capture as much of your targeted metrics.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.experimental.MetricConfigResponse.Schedule schedules = 2;</code>
     */
    java.util.List<? extends MetricConfigResponse.ScheduleOrBuilder>
    getSchedulesOrBuilderList();

    /**
     * <pre>
     * A single metric may match multiple schedules. In such cases, the schedule
     * that specifies the smallest period is applied.
     * Note, for optimization purposes, it is recommended to use as few schedules
     * as possible to capture all required metric updates. Where you can be
     * conservative, do take full advantage of the inclusion/exclusion patterns to
     * capture as much of your targeted metrics.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.experimental.MetricConfigResponse.Schedule schedules = 2;</code>
     */
    MetricConfigResponse.ScheduleOrBuilder getSchedulesOrBuilder(
            int index);

    /**
     * <pre>
     * Optional. The client is suggested to wait this long (in seconds) before
     * pinging the configuration service again.
     * </pre>
     *
     * <code>int32 suggested_wait_time_sec = 3;</code>
     *
     * @return The suggestedWaitTimeSec.
     */
    int getSuggestedWaitTimeSec();
}
