// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opentelemetry/proto/metrics/v1/metrics.proto

package io.opentelemetry.proto.metrics.v1;

@Deprecated
public interface IntHistogramDataPointOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.metrics.v1.IntHistogramDataPoint)
        com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The set of labels that uniquely identify this timeseries.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.common.v1.StringKeyValue labels = 1;</code>
     */
    java.util.List<io.opentelemetry.proto.common.v1.StringKeyValue>
    getLabelsList();

    /**
     * <pre>
     * The set of labels that uniquely identify this timeseries.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.common.v1.StringKeyValue labels = 1;</code>
     */
    io.opentelemetry.proto.common.v1.StringKeyValue getLabels(int index);

    /**
     * <pre>
     * The set of labels that uniquely identify this timeseries.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.common.v1.StringKeyValue labels = 1;</code>
     */
    int getLabelsCount();

    /**
     * <pre>
     * The set of labels that uniquely identify this timeseries.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.common.v1.StringKeyValue labels = 1;</code>
     */
    java.util.List<? extends io.opentelemetry.proto.common.v1.StringKeyValueOrBuilder>
    getLabelsOrBuilderList();

    /**
     * <pre>
     * The set of labels that uniquely identify this timeseries.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.common.v1.StringKeyValue labels = 1;</code>
     */
    io.opentelemetry.proto.common.v1.StringKeyValueOrBuilder getLabelsOrBuilder(
            int index);

    /**
     * <pre>
     * StartTimeUnixNano is optional but strongly encouraged, see the
     * the detiled comments above Metric.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     * </pre>
     *
     * <code>fixed64 start_time_unix_nano = 2;</code>
     *
     * @return The startTimeUnixNano.
     */
    long getStartTimeUnixNano();

    /**
     * <pre>
     * TimeUnixNano is required, see the detailed comments above Metric.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     * </pre>
     *
     * <code>fixed64 time_unix_nano = 3;</code>
     *
     * @return The timeUnixNano.
     */
    long getTimeUnixNano();

    /**
     * <pre>
     * count is the number of values in the population. Must be non-negative. This
     * value must be equal to the sum of the "count" fields in buckets if a
     * histogram is provided.
     * </pre>
     *
     * <code>fixed64 count = 4;</code>
     *
     * @return The count.
     */
    long getCount();

    /**
     * <pre>
     * sum of the values in the population. If count is zero then this field
     * must be zero. This value must be equal to the sum of the "sum" fields in
     * buckets if a histogram is provided.
     * </pre>
     *
     * <code>sfixed64 sum = 5;</code>
     *
     * @return The sum.
     */
    long getSum();

    /**
     * <pre>
     * bucket_counts is an optional field contains the count values of histogram
     * for each bucket.
     * The sum of the bucket_counts must equal the value in the count field.
     * The number of elements in bucket_counts array must be by one greater than
     * the number of elements in explicit_bounds array.
     * </pre>
     *
     * <code>repeated fixed64 bucket_counts = 6;</code>
     *
     * @return A list containing the bucketCounts.
     */
    java.util.List<Long> getBucketCountsList();

    /**
     * <pre>
     * bucket_counts is an optional field contains the count values of histogram
     * for each bucket.
     * The sum of the bucket_counts must equal the value in the count field.
     * The number of elements in bucket_counts array must be by one greater than
     * the number of elements in explicit_bounds array.
     * </pre>
     *
     * <code>repeated fixed64 bucket_counts = 6;</code>
     *
     * @return The count of bucketCounts.
     */
    int getBucketCountsCount();

    /**
     * <pre>
     * bucket_counts is an optional field contains the count values of histogram
     * for each bucket.
     * The sum of the bucket_counts must equal the value in the count field.
     * The number of elements in bucket_counts array must be by one greater than
     * the number of elements in explicit_bounds array.
     * </pre>
     *
     * <code>repeated fixed64 bucket_counts = 6;</code>
     *
     * @param index The index of the element to return.
     * @return The bucketCounts at the given index.
     */
    long getBucketCounts(int index);

    /**
     * <pre>
     * explicit_bounds specifies buckets with explicitly defined bounds for values.
     * The boundaries for bucket at index i are:
     * (-infinity, explicit_bounds[i]] for i == 0
     * (explicit_bounds[i-1], explicit_bounds[i]] for 0 &lt; i &lt; size(explicit_bounds)
     * (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
     * The values in the explicit_bounds array must be strictly increasing.
     * Histogram buckets are inclusive of their upper boundary, except the last
     * bucket where the boundary is at infinity. This format is intentionally
     * compatible with the OpenMetrics histogram definition.
     * </pre>
     *
     * <code>repeated double explicit_bounds = 7;</code>
     *
     * @return A list containing the explicitBounds.
     */
    java.util.List<Double> getExplicitBoundsList();

    /**
     * <pre>
     * explicit_bounds specifies buckets with explicitly defined bounds for values.
     * The boundaries for bucket at index i are:
     * (-infinity, explicit_bounds[i]] for i == 0
     * (explicit_bounds[i-1], explicit_bounds[i]] for 0 &lt; i &lt; size(explicit_bounds)
     * (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
     * The values in the explicit_bounds array must be strictly increasing.
     * Histogram buckets are inclusive of their upper boundary, except the last
     * bucket where the boundary is at infinity. This format is intentionally
     * compatible with the OpenMetrics histogram definition.
     * </pre>
     *
     * <code>repeated double explicit_bounds = 7;</code>
     *
     * @return The count of explicitBounds.
     */
    int getExplicitBoundsCount();

    /**
     * <pre>
     * explicit_bounds specifies buckets with explicitly defined bounds for values.
     * The boundaries for bucket at index i are:
     * (-infinity, explicit_bounds[i]] for i == 0
     * (explicit_bounds[i-1], explicit_bounds[i]] for 0 &lt; i &lt; size(explicit_bounds)
     * (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
     * The values in the explicit_bounds array must be strictly increasing.
     * Histogram buckets are inclusive of their upper boundary, except the last
     * bucket where the boundary is at infinity. This format is intentionally
     * compatible with the OpenMetrics histogram definition.
     * </pre>
     *
     * <code>repeated double explicit_bounds = 7;</code>
     *
     * @param index The index of the element to return.
     * @return The explicitBounds at the given index.
     */
    double getExplicitBounds(int index);

    /**
     * <pre>
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.v1.IntExemplar exemplars = 8;</code>
     */
    java.util.List<IntExemplar>
    getExemplarsList();

    /**
     * <pre>
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.v1.IntExemplar exemplars = 8;</code>
     */
    IntExemplar getExemplars(int index);

    /**
     * <pre>
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.v1.IntExemplar exemplars = 8;</code>
     */
    int getExemplarsCount();

    /**
     * <pre>
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.v1.IntExemplar exemplars = 8;</code>
     */
    java.util.List<? extends IntExemplarOrBuilder>
    getExemplarsOrBuilderList();

    /**
     * <pre>
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.metrics.v1.IntExemplar exemplars = 8;</code>
     */
    IntExemplarOrBuilder getExemplarsOrBuilder(
            int index);
}
